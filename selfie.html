<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>肩に乗る（自撮り）｜かなたけちゃん</title>

  <style>
    :root{
      --bg:#fbfaf7;
      --ink:#1f2328;
      --sub:rgba(31,35,40,.72);
      --line:rgba(31,35,40,.12);
      --card:rgba(255,255,255,.90);
      --shadow:0 16px 40px rgba(31,35,40,.10);
      --ume:#e94b5a;
      --mint:#2bb3a6;
      --radius:20px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,"Noto Sans JP",sans-serif;
      color:var(--ink);
      background:
        radial-gradient(12px 12px at 18px 18px, rgba(31,35,40,.035) 0 3px, transparent 3px),
        radial-gradient(12px 12px at 44px 54px, rgba(31,35,40,.030) 0 3px, transparent 3px),
        radial-gradient(900px 420px at 15% 0%, rgba(233,75,90,.10), transparent 60%),
        radial-gradient(900px 420px at 90% 10%, rgba(43,179,166,.08), transparent 55%),
        var(--bg);
      background-size:72px 72px,72px 72px,auto,auto,auto;
      min-height:100vh;
    }

    .wrap{max-width:920px;margin:0 auto;padding:18px 14px 22px}
    h1{margin:0 0 6px;font-size:18px}
    .sub{margin:0 0 12px;color:var(--sub);font-size:13.2px;line-height:1.8}

    .panel{
      background:var(--card);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }

    .stage{
      position:relative;
      width:100%;
      aspect-ratio: 3 / 4;
      background:#000;
    }
    @media (min-width: 920px){
      .stage{ aspect-ratio: 16 / 9; }
    }

    video{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit:cover;
      transform: scaleX(-1); /* 自撮り鏡 */
    }
    /* 背面カメラ時に鏡反転しない */
    video.no-mirror{ transform:none; }

    .overlay{
      position:absolute;
      left:50%;
      top:60%;
      width: 220px;
      height:auto;
      transform: translate(-50%,-50%);
      touch-action:none; /* ピンチとドラッグを自前で扱う */
      user-select:none;
      -webkit-user-drag:none;
      filter: drop-shadow(0 10px 14px rgba(0,0,0,.35));
    }

    .hud{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      padding:12px;
      border-top:1px solid var(--line);
      align-items:center;
      justify-content:space-between;
    }

    .left, .right{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }

    button{
      appearance:none;
      border:1px solid rgba(31,35,40,.14);
      background: rgba(255,255,255,.84);
      color: rgba(31,35,40,.90);
      border-radius: 14px;
      padding: 11px 12px;
      font-size: 13.2px;
      font-weight: 800;
    }
    button:active{ transform: scale(.99); }

    .primary{
      border-color: rgba(233,75,90,.28);
      background: linear-gradient(135deg, rgba(233,75,90,.96), rgba(233,75,90,.86));
      color:#fff;
      box-shadow: 0 14px 26px rgba(233,75,90,.18);
    }

    .hint{
      padding: 10px 12px 14px;
      color: rgba(31,35,40,.70);
      font-size: 12.4px;
      line-height: 1.8;
    }

    .toast{
      position:fixed;
      left:50%;
      bottom:16px;
      transform:translateX(-50%);
      background: rgba(31,35,40,.88);
      color:#fff;
      padding:10px 12px;
      border-radius: 999px;
      font-size: 12.5px;
      opacity:0;
      pointer-events:none;
      transition: opacity .2s ease;
    }
    .toast.show{ opacity:1; }

    a.back{
      margin-top: 12px;
      display:inline-block;
      text-decoration:none;
      color: rgba(31,35,40,.80);
      border: 1px solid rgba(31,35,40,.14);
      background: rgba(255,255,255,.70);
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 13px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>肩に乗る（自撮り）</h1>
    <p class="sub">
      かなたけちゃんを<strong>ドラッグ</strong>で移動、<strong>ピンチ</strong>で拡大縮小できます。<br>
      位置が決まったら「撮影」を押してください。
    </p>

    <div class="panel">
      <div class="stage" id="stage">
        <video id="video" autoplay playsinline muted></video>
        <img id="overlay" class="overlay" src="./onigiriya_kanatake_512.png" alt="かなたけちゃん">
      </div>

      <div class="hud">
        <div class="left">
          <button id="switchBtn" type="button">カメラ切替</button>
          <button id="resetBtn" type="button">位置リセット</button>
        </div>
        <div class="right">
          <button id="shotBtn" class="primary" type="button">撮影</button>
        </div>
      </div>

      <div class="hint">
        ※保存がうまくいかない場合は、撮影後に表示される画像を長押しして保存してください。<br>
        ※周囲のお客さまが写り込まないようご配慮ください。
      </div>
    </div>

    <a class="back" href="./">← トップへ戻る</a>
  </div>

  <div class="toast" id="toast">準備中…</div>

  <canvas id="canvas" style="display:none"></canvas>

  <script>
    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const canvas = document.getElementById('canvas');
    const toast = document.getElementById('toast');

    const switchBtn = document.getElementById('switchBtn');
    const resetBtn  = document.getElementById('resetBtn');
    const shotBtn   = document.getElementById('shotBtn');

    let facingMode = 'user'; // 'user' or 'environment'
    let stream = null;

    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add('show');
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=>toast.classList.remove('show'), 1600);
    }

    async function startCamera(){
      try{
        if(stream){
          stream.getTracks().forEach(t=>t.stop());
          stream = null;
        }
        showToast('カメラを起動しています…');

        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode },
          audio: false
        });

        video.srcObject = stream;

        // 鏡反転：自撮りだけ
        if(facingMode === 'user'){
          video.classList.remove('no-mirror');
        }else{
          video.classList.add('no-mirror');
        }

        showToast('準備できました');
      }catch(e){
        console.error(e);
        showToast('カメラを許可してください');
        alert('カメラの許可が必要です。ブラウザの設定でカメラを許可してからお試しください。');
      }
    }

    // ---- Overlay transform (drag + pinch) ----
    let state = {
      x: 0, y: 0, scale: 1,
      startX: 0, startY: 0,
      startScale: 1
    };

    function applyTransform(){
      overlay.style.transform = `translate(-50%,-50%) translate(${state.x}px, ${state.y}px) scale(${state.scale})`;
    }

    function resetOverlay(){
      state.x = 0;
      state.y = 0;
      state.scale = 1;
      applyTransform();
      showToast('リセットしました');
    }

    // Pointer tracking for pinch
    const pointers = new Map();

    function getDistance(a,b){
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.hypot(dx,dy);
    }

    function getMidpoint(a,b){
      return { x: (a.x+b.x)/2, y: (a.y+b.y)/2 };
    }

    let pinchStartDist = 0;
    let pinchStartScale = 1;
    let pinchStartMid = null;
    let dragStart = null;

    overlay.addEventListener('pointerdown', (ev)=>{
      overlay.setPointerCapture(ev.pointerId);
      pointers.set(ev.pointerId, { x: ev.clientX, y: ev.clientY });

      if(pointers.size === 1){
        // drag start
        dragStart = { x: ev.clientX, y: ev.clientY, ox: state.x, oy: state.y };
      }else if(pointers.size === 2){
        const pts = [...pointers.values()];
        pinchStartDist = getDistance(pts[0], pts[1]);
        pinchStartScale = state.scale;
        pinchStartMid = getMidpoint(pts[0], pts[1]);
      }
    });

    overlay.addEventListener('pointermove', (ev)=>{
      if(!pointers.has(ev.pointerId)) return;
      pointers.set(ev.pointerId, { x: ev.clientX, y: ev.clientY });

      if(pointers.size === 1 && dragStart){
        const p = [...pointers.values()][0];
        state.x = dragStart.ox + (p.x - dragStart.x);
        state.y = dragStart.oy + (p.y - dragStart.y);
        applyTransform();
      }else if(pointers.size === 2){
        const pts = [...pointers.values()];
        const dist = getDistance(pts[0], pts[1]);
        const mid = getMidpoint(pts[0], pts[1]);

        const scale = pinchStartScale * (dist / pinchStartDist);
        // clamp
        state.scale = Math.max(0.35, Math.min(2.6, scale));

        // 2本指の中心が動いた分も平行移動
        if(pinchStartMid){
          state.x += (mid.x - pinchStartMid.x);
          state.y += (mid.y - pinchStartMid.y);
          pinchStartMid = mid;
        }
        applyTransform();
      }
    });

    function endPointer(ev){
      pointers.delete(ev.pointerId);
      if(pointers.size < 2){
        pinchStartMid = null;
      }
      if(pointers.size === 0){
        dragStart = null;
      }else if(pointers.size === 1){
        const p = [...pointers.values()][0];
        dragStart = { x: p.x, y: p.y, ox: state.x, oy: state.y };
      }
    }

    overlay.addEventListener('pointerup', endPointer);
    overlay.addEventListener('pointercancel', endPointer);
    overlay.addEventListener('lostpointercapture', endPointer);

    // ---- Capture ----
    function getVideoSize(){
      const vw = video.videoWidth;
      const vh = video.videoHeight;
      return { vw, vh };
    }

    function drawCover(ctx, img, dx, dy, dw, dh){
      // draw image "cover" into dw×dh
      const iw = img.width, ih = img.height;
      const ir = iw / ih;
      const dr = dw / dh;
      let sw, sh, sx, sy;
      if(ir > dr){
        sh = ih;
        sw = ih * dr;
        sx = (iw - sw) / 2;
        sy = 0;
      }else{
        sw = iw;
        sh = iw / dr;
        sx = 0;
        sy = (ih - sh) / 2;
      }
      ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);
    }

    shotBtn.addEventListener('click', async ()=>{
      if(!video.videoWidth){
        showToast('カメラ準備中です');
        return;
      }

      // canvas size = stage display size * devicePixelRatio
      const stage = document.getElementById('stage');
      const rect = stage.getBoundingClientRect();
      const dpr = Math.min(2, window.devicePixelRatio || 1);

      canvas.width  = Math.round(rect.width * dpr);
      canvas.height = Math.round(rect.height * dpr);

      const ctx = canvas.getContext('2d');

      // video draw (cover into stage)
      // For user camera, we mirror to match what user sees.
      ctx.save();
      if(facingMode === 'user'){
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);
      }
      drawCover(ctx, video, 0, 0, canvas.width, canvas.height);
      ctx.restore();

      // overlay draw at its on-screen position
      // Compute overlay center position relative to stage
      const orect = overlay.getBoundingClientRect();
      const srect = stage.getBoundingClientRect();

      const ox = (orect.left - srect.left) * dpr;
      const oy = (orect.top  - srect.top ) * dpr;
      const ow = orect.width * dpr;
      const oh = orect.height * dpr;

      // ensure overlay image is loaded
      await overlay.decode?.().catch(()=>{});

      ctx.drawImage(overlay, ox, oy, ow, oh);

      // export
      const blob = await new Promise(res => canvas.toBlob(res, 'image/png', 1.0));
      if(!blob){
        showToast('撮影に失敗しました');
        return;
      }

      const file = new File([blob], 'kanatake_selfie.png', { type: 'image/png' });

      // iOS Safari: share sheet if possible
      if(navigator.canShare && navigator.canShare({ files: [file] })){
        try{
          await navigator.share({ files: [file], title: 'かなたけちゃんAR' });
          showToast('共有を開きました');
          return;
        }catch(e){
          // user cancelled
        }
      }

      // fallback: open image in new tab (long press save) + download link
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'kanatake_selfie.png';
      document.body.appendChild(a);
      a.click();
      a.remove();

      // also show in new tab for iOS (download might not work)
      window.open(url, '_blank', 'noopener,noreferrer');
      showToast('画像を保存してください');
      setTimeout(()=>URL.revokeObjectURL(url), 8000);
    });

    // Buttons
    switchBtn.addEventListener('click', async ()=>{
      facingMode = (facingMode === 'user') ? 'environment' : 'user';
      await startCamera();
      showToast(facingMode === 'user' ? '前カメラ' : '後ろカメラ');
    });
    resetBtn.addEventListener('click', resetOverlay);

    // Init
    resetOverlay();
    startCamera();
  </script>
</body>
</html>
